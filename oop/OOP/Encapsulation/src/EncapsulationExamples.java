
public class EncapsulationExamples {
    public static void main(String[] args) {
        // инкапсулация - скриване на имплементация, чрез използване на модификатор за достъп (access modifier) -> private, public..
        // инкапсулацията е възможността, или начина по който аз мога да взема някаква информация и код и да го съхраня в един клас по безопасен начин.
        // Вземам едно парче код и го скривам в класа. Инкапсулацията играе роля на една защитна бариера, не позволява този код да бъде достъпван извън рамките на класа.

        // Utility class - клас, който съдържа статични методи, не е предназначен да се инстанцира - класове: Math

        //

        // class - PersonExample
        // пример за думата this - която реферира към текущата инстанция
        PersonExample person = new PersonExample("Zlati", 34);
        System.out.println(person.getAge());
        System.out.println(person.getName());

        // този статичен метод няма нужда от инстнация (person), както по-горе методите getAge() & getName()
        PersonExample.printInfo();

        // Access Modifier -> private, protected, default,
        // top level class-a не може да бъде private


        /////////// VALIDATIONS
        // използваме сетърите, за да направим проверка преди да направим запис в инстанцията

        /////////// MUTABLE & IMMUTABLE OBJECTS
        // обект да може да бъде променян
        // стринга не може да бъде променян, всички методи на класа Стринг връщат нов стринг, но не променят оригиналният

        // пакет Teams -> ако класа има сетери той е Mutable, ако няма ние няма как да променяме полетата и това го прави Immutable
        // ако имаме Getter към контретен списък, така можем да манипулираме обекта
        // ако Getter-a връща return Collections.unmodifiableList(people); такъв тип няма как да бъде променян


        /////////// KEYWORD FINAL

        // пример в пакет School

        // по този начин веднъж заложена стойност на променлива няма как да бъде променена
        // когато имаме клас, който е FINAL - той няма как да бъде наследен
        // когато имаме метод, който е FINAL - той не може да бъде пренаписван
        // когато имаме final list - той не може да бъде заменен с нов списък, но може да бъде променен - тоест да го съкратим или удължим


    }
}